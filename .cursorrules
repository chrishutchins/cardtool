# CardTool Project Rules

## Project Info
- **Domain**: cardtool.app
- **Production URL**: https://cardtool.app

## Database Schema Changes
When creating Supabase migrations that add or modify tables/columns:
1. Create the migration in `supabase/migrations/`
2. **ALWAYS update `src/lib/database.types.ts`** in the same commit to include the new types
3. The types file must stay in sync with the database schema or builds will fail
4. **ALWAYS enable RLS on new tables** - see RLS section below
5. **ALWAYS run migrations using Supabase MCP tools** - see Running Migrations section below

## Running Migrations
Use the Supabase MCP tools to run migrations against the database. Do NOT tell the user to run SQL manually.

- Use `CallMcpTool` with server `user-supabase` and tool `execute_sql` to run SQL queries
- For DDL operations (CREATE TABLE, ALTER TABLE, etc.), you can also use `apply_migration`
- If a migration is complex, break it into smaller `execute_sql` calls to avoid errors
- Always verify the migration succeeded by querying the affected tables

Example:
```
CallMcpTool(server: "user-supabase", toolName: "execute_sql", arguments: {"query": "ALTER TABLE cards ADD COLUMN brand text;"})
```

## Row Level Security (RLS)
All tables must have RLS enabled, even though the app primarily uses the service role key (which bypasses RLS). This provides defense-in-depth against direct database access via the anon key.

When creating a new table:
1. Enable RLS: `ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;`
2. Add appropriate policy based on table type:

**User tables** (have `user_id` column):
```sql
CREATE POLICY "Users can manage their own data"
  ON table_name FOR ALL TO authenticated
  USING (user_id = (auth.jwt()->>'sub'))
  WITH CHECK (user_id = (auth.jwt()->>'sub'));
```

**Reference tables** (read-only shared data like `cards`, `issuers`):
```sql
CREATE POLICY "Authenticated users can read table_name"
  ON table_name FOR SELECT TO authenticated
  USING (true);
```

**Service-role-only tables** (like `stripe_members`):
- Enable RLS but add NO policies - this blocks all non-service-role access

## Tech Stack
- Next.js 16 with App Router
- Supabase for database (service role key for app access, RLS + Clerk JWT for defense-in-depth)
- Clerk for authentication
- Tailwind CSS for styling
- TypeScript throughout

## Code Style
- Use server components by default, client components only when needed
- Server actions for mutations (in page.tsx files with "use server")
- Dark theme UI (zinc-900/950 backgrounds, zinc-300/400 text)
- Consistent tooltip style using fixed positioning (see existing Tooltip components)

## Git Workflow
- **NEVER commit or push to main unless explicitly instructed by the user for THAT SPECIFIC change**
- A "push" instruction applies ONLY to the changes discussed at that moment, NOT future changes
- Always run `npm run build` and verify it passes before any commit
- After fixing bugs or making changes, ALWAYS ask "Ready to push?" before pushing
- When in doubt, ask first

## Testing
- Build must pass (`npm run build`) before pushing
- Test UI changes in browser before considering complete

## Date Handling Standards

### Storage Format
- Date-only fields: `YYYY-MM-DD` string (e.g., `approval_date`, `expiration_date`)
- Timestamp fields: Full ISO string via `new Date().toISOString()` (e.g., `updated_at`, `created_at`)

### Date Utilities (from `@/lib/utils`)
- `parseLocalDate(str)` - Parse YYYY-MM-DD to Date in local timezone
- `formatDateToString(date)` - Format Date to YYYY-MM-DD in local timezone
- `formatDate(str, options)` - Format date string for display
- `extractDateFromISO(str)` - Extract YYYY-MM-DD from ISO string without timezone conversion

### Rules
1. **NEVER** use `new Date(dateString)` for date-only strings - use `parseLocalDate()`
2. **NEVER** use `date.toISOString().split('T')[0]` for local dates - use `formatDateToString()`
3. **NEVER** duplicate date utilities in components - import from `@/lib/utils`
4. For ISO strings with time, extract date directly: `str.substring(0, 10)` or `extractDateFromISO()`

### Why This Matters
JavaScript's `new Date("2024-01-15")` parses as UTC midnight, which can shift to the previous day in US timezones. Similarly, `toISOString()` converts to UTC, which can cause Â±1 day errors. Always use the utilities above to avoid these timezone bugs.
